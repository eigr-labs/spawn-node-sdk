// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "actor.proto" (package "eigr.functions.protocol.actors", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Any } from '../../../../google/any'
/**
 * @generated from protobuf message eigr.functions.protocol.actors.Registry
 */
export interface Registry {
  /**
   * @generated from protobuf field: map<string, eigr.functions.protocol.actors.Actor> actors = 1;
   */
  actors: {
    [key: string]: Actor
  }
}
/**
 * @generated from protobuf message eigr.functions.protocol.actors.ActorSystem
 */
export interface ActorSystem {
  /**
   * @generated from protobuf field: string name = 1;
   */
  name: string
  /**
   * @generated from protobuf field: eigr.functions.protocol.actors.Registry registry = 2;
   */
  registry?: Registry
}
/**
 * A strategy for save state.
 *
 * @generated from protobuf message eigr.functions.protocol.actors.ActorSnapshotStrategy
 */
export interface ActorSnapshotStrategy {
  /**
   * @generated from protobuf oneof: strategy
   */
  strategy:
    | {
        oneofKind: 'timeout'
        /**
         * the timeout strategy.
         *
         * @generated from protobuf field: eigr.functions.protocol.actors.TimeoutStrategy timeout = 1;
         */
        timeout: TimeoutStrategy
      }
    | {
        oneofKind: undefined
      }
}
/**
 * A strategy which a user function's entity is passivated.
 *
 * @generated from protobuf message eigr.functions.protocol.actors.ActorDeactivationStrategy
 */
export interface ActorDeactivationStrategy {
  /**
   * @generated from protobuf oneof: strategy
   */
  strategy:
    | {
        oneofKind: 'timeout'
        /**
         * the timeout strategy.
         *
         * @generated from protobuf field: eigr.functions.protocol.actors.TimeoutStrategy timeout = 1;
         */
        timeout: TimeoutStrategy
      }
    | {
        oneofKind: undefined
      }
}
/**
 * A strategy based on a timeout.
 *
 * @generated from protobuf message eigr.functions.protocol.actors.TimeoutStrategy
 */
export interface TimeoutStrategy {
  /**
   * The timeout in millis
   *
   * @generated from protobuf field: int64 timeout = 1;
   */
  timeout: bigint
}
/**
 * A command represents an action that the user can perform on an Actor.
 * Commands in supporting languages are represented by functions or methods.
 * An Actor command has nothing to do with the semantics of Commands in a CQRS/EventSourced system.
 * It just represents an action that supporting languages can invoke.
 *
 * @generated from protobuf message eigr.functions.protocol.actors.Command
 */
export interface Command {
  /**
   * The name of the function or method in the supporting language that has been registered in Ator.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string
}
/**
 * A FixedTimerCommand is similar to a regular Command, its main differences are that it is scheduled to run at regular intervals
 * and only takes the actor's state as an argument.
 * Timer Commands are good for executing loops that manipulate the actor's own state.
 * In Elixir or other languages in BEAM it would be similar to invoking Process.send_after(self(), atom, msg, timeout)
 *
 * @generated from protobuf message eigr.functions.protocol.actors.FixedTimerCommand
 */
export interface FixedTimerCommand {
  /**
   * The time to wait until the command is triggered
   *
   * @generated from protobuf field: int32 seconds = 1;
   */
  seconds: number
  /**
   * See Command description Above
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.Command command = 2;
   */
  command?: Command
}
/**
 * @generated from protobuf message eigr.functions.protocol.actors.ActorState
 */
export interface ActorState {
  /**
   * @generated from protobuf field: map<string, string> tags = 1;
   */
  tags: {
    [key: string]: string
  }
  /**
   * @generated from protobuf field: google.protobuf.Any state = 2;
   */
  state?: Any
}
/**
 * TODO doc here
 *
 * @generated from protobuf message eigr.functions.protocol.actors.Metadata
 */
export interface Metadata {
  /**
   * A channel group represents a way to send commands to various actors
   * that belong to a certain semantic group.
   *
   * @generated from protobuf field: string channel_group = 1;
   */
  channelGroup: string
  /**
   * @generated from protobuf field: map<string, string> tags = 2;
   */
  tags: {
    [key: string]: string
  }
}
/**
 * @generated from protobuf message eigr.functions.protocol.actors.ActorSettings
 */
export interface ActorSettings {
  /**
   * Indicates the type of Actor to be configured.
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.Kind kind = 1;
   */
  kind: Kind
  /**
   * Indicates whether an actor's state should be persisted in a definitive store.
   *
   * @generated from protobuf field: bool stateful = 2;
   */
  stateful: boolean
  /**
   * Snapshot strategy
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorSnapshotStrategy snapshot_strategy = 3;
   */
  snapshotStrategy?: ActorSnapshotStrategy
  /**
   * Deactivate strategy
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorDeactivationStrategy deactivation_strategy = 4;
   */
  deactivationStrategy?: ActorDeactivationStrategy
  /**
   * When kind is POOLED this is used to define minimun actor instances
   *
   * @generated from protobuf field: int32 min_pool_size = 5;
   */
  minPoolSize: number
  /**
   * When kind is POOLED this is used to define maximum actor instances
   *
   * @generated from protobuf field: int32 max_pool_size = 6;
   */
  maxPoolSize: number
}
/**
 * @generated from protobuf message eigr.functions.protocol.actors.ActorId
 */
export interface ActorId {
  /**
   * The name of a Actor Entity.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string
  /**
   * Name of a ActorSystem
   *
   * @generated from protobuf field: string system = 2;
   */
  system: string
  /**
   * When the Actor is of the Abstract type,
   * the name of the parent Actor must be informed here.
   *
   * @generated from protobuf field: string parent = 3;
   */
  parent: string
}
/**
 * @generated from protobuf message eigr.functions.protocol.actors.Actor
 */
export interface Actor {
  /**
   * Actor Identification
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorId id = 1;
   */
  id?: ActorId
  /**
   * A Actor state.
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorState state = 2;
   */
  state?: ActorState
  /**
   * Actor metadata
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.Metadata metadata = 6;
   */
  metadata?: Metadata
  /**
   * Actor settings.
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorSettings settings = 3;
   */
  settings?: ActorSettings
  /**
   * The commands registered for an actor
   *
   * @generated from protobuf field: repeated eigr.functions.protocol.actors.Command commands = 4;
   */
  commands: Command[]
  /**
   * The registered timer commands for an actor.
   *
   * @generated from protobuf field: repeated eigr.functions.protocol.actors.FixedTimerCommand timer_commands = 5;
   */
  timerCommands: FixedTimerCommand[]
}
/**
 * The type that defines the runtime characteristics of the Actor.
 * Regardless of the type of actor it is important that
 * all actors are registered during the proxy and host initialization phase.
 *
 * @generated from protobuf enum eigr.functions.protocol.actors.Kind
 */
export enum Kind {
  /**
   * When no type is informed, the default to be assumed will be the Singleton pattern.
   *
   * @generated from protobuf enum value: UNKNOW_KIND = 0;
   */
  UNKNOW_KIND = 0,
  /**
   * Abstract actors are used to create children of this based actor at runtime
   *
   * @generated from protobuf enum value: ABSTRACT = 1;
   */
  ABSTRACT = 1,
  /**
   * Singleton actors as the name suggests have only one real instance of themselves running
   * during their entire lifecycle. That is, they are the opposite of the Abstract type Actors.
   *
   * @generated from protobuf enum value: SINGLETON = 2;
   */
  SINGLETON = 2,
  /**
   * Pooled Actors are similar to abstract actors, but unlike them,
   * their identifying name will always be the one registered at the system initialization stage.
   * The great advantage of Pooled actors is that they have multiple instances of themselves
   * acting as a request service pool.
   * Pooled actors are also stateless actors, that is, they will not have their
   * in-memory state persisted via Statesstore. This is done to avoid problems
   * with the correctness of the stored state.
   * Pooled Actors are generally used for tasks where the Actor Model would perform worse
   * than other concurrency models and for tasks that do not require state concerns.
   * Integration flows, data caching, proxies are good examples of use cases
   * for this type of Actor.
   *
   * @generated from protobuf enum value: POOLED = 3;
   */
  POOLED = 3,
  /**
   * Reserved for future use
   *
   * @generated from protobuf enum value: PROXY = 4;
   */
  PROXY = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class Registry$Type extends MessageType<Registry> {
  constructor() {
    super('eigr.functions.protocol.actors.Registry', [
      {
        no: 1,
        name: 'actors',
        kind: 'map',
        K: 9 /*ScalarType.STRING*/,
        V: { kind: 'message', T: () => Actor }
      }
    ])
  }
  create(value?: PartialMessage<Registry>): Registry {
    const message = { actors: {} }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Registry>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Registry
  ): Registry {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* map<string, eigr.functions.protocol.actors.Actor> actors */ 1:
          this.binaryReadMap1(message.actors, reader, options)
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  private binaryReadMap1(
    map: Registry['actors'],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof Registry['actors'] | undefined,
      val: Registry['actors'][any] | undefined
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case 1:
          key = reader.string()
          break
        case 2:
          val = Actor.internalBinaryRead(reader, reader.uint32(), options)
          break
        default:
          throw new globalThis.Error(
            'unknown map entry field for field eigr.functions.protocol.actors.Registry.actors'
          )
      }
    }
    map[key ?? ''] = val ?? Actor.create()
  }
  internalBinaryWrite(
    message: Registry,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, eigr.functions.protocol.actors.Actor> actors = 1; */
    for (let k of Object.keys(message.actors)) {
      writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k)
      writer.tag(2, WireType.LengthDelimited).fork()
      Actor.internalBinaryWrite(message.actors[k], writer, options)
      writer.join().join()
    }
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.Registry
 */
export const Registry = new Registry$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ActorSystem$Type extends MessageType<ActorSystem> {
  constructor() {
    super('eigr.functions.protocol.actors.ActorSystem', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'registry', kind: 'message', T: () => Registry }
    ])
  }
  create(value?: PartialMessage<ActorSystem>): ActorSystem {
    const message = { name: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ActorSystem>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ActorSystem
  ): ActorSystem {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* eigr.functions.protocol.actors.Registry registry */ 2:
          message.registry = Registry.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.registry
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ActorSystem,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* eigr.functions.protocol.actors.Registry registry = 2; */
    if (message.registry)
      Registry.internalBinaryWrite(
        message.registry,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.ActorSystem
 */
export const ActorSystem = new ActorSystem$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ActorSnapshotStrategy$Type extends MessageType<ActorSnapshotStrategy> {
  constructor() {
    super('eigr.functions.protocol.actors.ActorSnapshotStrategy', [
      { no: 1, name: 'timeout', kind: 'message', oneof: 'strategy', T: () => TimeoutStrategy }
    ])
  }
  create(value?: PartialMessage<ActorSnapshotStrategy>): ActorSnapshotStrategy {
    const message = { strategy: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ActorSnapshotStrategy>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ActorSnapshotStrategy
  ): ActorSnapshotStrategy {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.actors.TimeoutStrategy timeout */ 1:
          message.strategy = {
            oneofKind: 'timeout',
            timeout: TimeoutStrategy.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.strategy as any).timeout
            )
          }
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ActorSnapshotStrategy,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.actors.TimeoutStrategy timeout = 1; */
    if (message.strategy.oneofKind === 'timeout')
      TimeoutStrategy.internalBinaryWrite(
        message.strategy.timeout,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.ActorSnapshotStrategy
 */
export const ActorSnapshotStrategy = new ActorSnapshotStrategy$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ActorDeactivationStrategy$Type extends MessageType<ActorDeactivationStrategy> {
  constructor() {
    super('eigr.functions.protocol.actors.ActorDeactivationStrategy', [
      { no: 1, name: 'timeout', kind: 'message', oneof: 'strategy', T: () => TimeoutStrategy }
    ])
  }
  create(value?: PartialMessage<ActorDeactivationStrategy>): ActorDeactivationStrategy {
    const message = { strategy: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ActorDeactivationStrategy>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ActorDeactivationStrategy
  ): ActorDeactivationStrategy {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.actors.TimeoutStrategy timeout */ 1:
          message.strategy = {
            oneofKind: 'timeout',
            timeout: TimeoutStrategy.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.strategy as any).timeout
            )
          }
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ActorDeactivationStrategy,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.actors.TimeoutStrategy timeout = 1; */
    if (message.strategy.oneofKind === 'timeout')
      TimeoutStrategy.internalBinaryWrite(
        message.strategy.timeout,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.ActorDeactivationStrategy
 */
export const ActorDeactivationStrategy = new ActorDeactivationStrategy$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TimeoutStrategy$Type extends MessageType<TimeoutStrategy> {
  constructor() {
    super('eigr.functions.protocol.actors.TimeoutStrategy', [
      {
        no: 1,
        name: 'timeout',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/
      }
    ])
  }
  create(value?: PartialMessage<TimeoutStrategy>): TimeoutStrategy {
    const message = { timeout: 0n }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<TimeoutStrategy>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TimeoutStrategy
  ): TimeoutStrategy {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int64 timeout */ 1:
          message.timeout = reader.int64().toBigInt()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: TimeoutStrategy,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int64 timeout = 1; */
    if (message.timeout !== 0n) writer.tag(1, WireType.Varint).int64(message.timeout)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.TimeoutStrategy
 */
export const TimeoutStrategy = new TimeoutStrategy$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Command$Type extends MessageType<Command> {
  constructor() {
    super('eigr.functions.protocol.actors.Command', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<Command>): Command {
    const message = { name: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Command>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Command
  ): Command {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Command,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.Command
 */
export const Command = new Command$Type()
// @generated message type with reflection information, may provide speed optimized methods
class FixedTimerCommand$Type extends MessageType<FixedTimerCommand> {
  constructor() {
    super('eigr.functions.protocol.actors.FixedTimerCommand', [
      { no: 1, name: 'seconds', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: 'command', kind: 'message', T: () => Command }
    ])
  }
  create(value?: PartialMessage<FixedTimerCommand>): FixedTimerCommand {
    const message = { seconds: 0 }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<FixedTimerCommand>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FixedTimerCommand
  ): FixedTimerCommand {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 seconds */ 1:
          message.seconds = reader.int32()
          break
        case /* eigr.functions.protocol.actors.Command command */ 2:
          message.command = Command.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.command
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: FixedTimerCommand,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int32 seconds = 1; */
    if (message.seconds !== 0) writer.tag(1, WireType.Varint).int32(message.seconds)
    /* eigr.functions.protocol.actors.Command command = 2; */
    if (message.command)
      Command.internalBinaryWrite(
        message.command,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.FixedTimerCommand
 */
export const FixedTimerCommand = new FixedTimerCommand$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ActorState$Type extends MessageType<ActorState> {
  constructor() {
    super('eigr.functions.protocol.actors.ActorState', [
      {
        no: 1,
        name: 'tags',
        kind: 'map',
        K: 9 /*ScalarType.STRING*/,
        V: { kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
      },
      { no: 2, name: 'state', kind: 'message', T: () => Any }
    ])
  }
  create(value?: PartialMessage<ActorState>): ActorState {
    const message = { tags: {} }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ActorState>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ActorState
  ): ActorState {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* map<string, string> tags */ 1:
          this.binaryReadMap1(message.tags, reader, options)
          break
        case /* google.protobuf.Any state */ 2:
          message.state = Any.internalBinaryRead(reader, reader.uint32(), options, message.state)
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  private binaryReadMap1(
    map: ActorState['tags'],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof ActorState['tags'] | undefined,
      val: ActorState['tags'][any] | undefined
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case 1:
          key = reader.string()
          break
        case 2:
          val = reader.string()
          break
        default:
          throw new globalThis.Error(
            'unknown map entry field for field eigr.functions.protocol.actors.ActorState.tags'
          )
      }
    }
    map[key ?? ''] = val ?? ''
  }
  internalBinaryWrite(
    message: ActorState,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, string> tags = 1; */
    for (let k of Object.keys(message.tags))
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.LengthDelimited)
        .string(message.tags[k])
        .join()
    /* google.protobuf.Any state = 2; */
    if (message.state)
      Any.internalBinaryWrite(
        message.state,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.ActorState
 */
export const ActorState = new ActorState$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
  constructor() {
    super('eigr.functions.protocol.actors.Metadata', [
      { no: 1, name: 'channel_group', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'tags',
        kind: 'map',
        K: 9 /*ScalarType.STRING*/,
        V: { kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
      }
    ])
  }
  create(value?: PartialMessage<Metadata>): Metadata {
    const message = { channelGroup: '', tags: {} }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Metadata>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Metadata
  ): Metadata {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string channel_group */ 1:
          message.channelGroup = reader.string()
          break
        case /* map<string, string> tags */ 2:
          this.binaryReadMap2(message.tags, reader, options)
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  private binaryReadMap2(
    map: Metadata['tags'],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof Metadata['tags'] | undefined,
      val: Metadata['tags'][any] | undefined
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case 1:
          key = reader.string()
          break
        case 2:
          val = reader.string()
          break
        default:
          throw new globalThis.Error(
            'unknown map entry field for field eigr.functions.protocol.actors.Metadata.tags'
          )
      }
    }
    map[key ?? ''] = val ?? ''
  }
  internalBinaryWrite(
    message: Metadata,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string channel_group = 1; */
    if (message.channelGroup !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.channelGroup)
    /* map<string, string> tags = 2; */
    for (let k of Object.keys(message.tags))
      writer
        .tag(2, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.LengthDelimited)
        .string(message.tags[k])
        .join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.Metadata
 */
export const Metadata = new Metadata$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ActorSettings$Type extends MessageType<ActorSettings> {
  constructor() {
    super('eigr.functions.protocol.actors.ActorSettings', [
      { no: 1, name: 'kind', kind: 'enum', T: () => ['eigr.functions.protocol.actors.Kind', Kind] },
      { no: 2, name: 'stateful', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 3, name: 'snapshot_strategy', kind: 'message', T: () => ActorSnapshotStrategy },
      { no: 4, name: 'deactivation_strategy', kind: 'message', T: () => ActorDeactivationStrategy },
      { no: 5, name: 'min_pool_size', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 6, name: 'max_pool_size', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<ActorSettings>): ActorSettings {
    const message = { kind: 0, stateful: false, minPoolSize: 0, maxPoolSize: 0 }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ActorSettings>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ActorSettings
  ): ActorSettings {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.actors.Kind kind */ 1:
          message.kind = reader.int32()
          break
        case /* bool stateful */ 2:
          message.stateful = reader.bool()
          break
        case /* eigr.functions.protocol.actors.ActorSnapshotStrategy snapshot_strategy */ 3:
          message.snapshotStrategy = ActorSnapshotStrategy.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.snapshotStrategy
          )
          break
        case /* eigr.functions.protocol.actors.ActorDeactivationStrategy deactivation_strategy */ 4:
          message.deactivationStrategy = ActorDeactivationStrategy.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.deactivationStrategy
          )
          break
        case /* int32 min_pool_size */ 5:
          message.minPoolSize = reader.int32()
          break
        case /* int32 max_pool_size */ 6:
          message.maxPoolSize = reader.int32()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ActorSettings,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.actors.Kind kind = 1; */
    if (message.kind !== 0) writer.tag(1, WireType.Varint).int32(message.kind)
    /* bool stateful = 2; */
    if (message.stateful !== false) writer.tag(2, WireType.Varint).bool(message.stateful)
    /* eigr.functions.protocol.actors.ActorSnapshotStrategy snapshot_strategy = 3; */
    if (message.snapshotStrategy)
      ActorSnapshotStrategy.internalBinaryWrite(
        message.snapshotStrategy,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.ActorDeactivationStrategy deactivation_strategy = 4; */
    if (message.deactivationStrategy)
      ActorDeactivationStrategy.internalBinaryWrite(
        message.deactivationStrategy,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* int32 min_pool_size = 5; */
    if (message.minPoolSize !== 0) writer.tag(5, WireType.Varint).int32(message.minPoolSize)
    /* int32 max_pool_size = 6; */
    if (message.maxPoolSize !== 0) writer.tag(6, WireType.Varint).int32(message.maxPoolSize)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.ActorSettings
 */
export const ActorSettings = new ActorSettings$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ActorId$Type extends MessageType<ActorId> {
  constructor() {
    super('eigr.functions.protocol.actors.ActorId', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'system', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'parent', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<ActorId>): ActorId {
    const message = { name: '', system: '', parent: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ActorId>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ActorId
  ): ActorId {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* string system */ 2:
          message.system = reader.string()
          break
        case /* string parent */ 3:
          message.parent = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ActorId,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* string system = 2; */
    if (message.system !== '') writer.tag(2, WireType.LengthDelimited).string(message.system)
    /* string parent = 3; */
    if (message.parent !== '') writer.tag(3, WireType.LengthDelimited).string(message.parent)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.ActorId
 */
export const ActorId = new ActorId$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Actor$Type extends MessageType<Actor> {
  constructor() {
    super('eigr.functions.protocol.actors.Actor', [
      { no: 1, name: 'id', kind: 'message', T: () => ActorId },
      { no: 2, name: 'state', kind: 'message', T: () => ActorState },
      { no: 6, name: 'metadata', kind: 'message', T: () => Metadata },
      { no: 3, name: 'settings', kind: 'message', T: () => ActorSettings },
      {
        no: 4,
        name: 'commands',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Command
      },
      {
        no: 5,
        name: 'timer_commands',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => FixedTimerCommand
      }
    ])
  }
  create(value?: PartialMessage<Actor>): Actor {
    const message = { commands: [], timerCommands: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Actor>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Actor
  ): Actor {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.actors.ActorId id */ 1:
          message.id = ActorId.internalBinaryRead(reader, reader.uint32(), options, message.id)
          break
        case /* eigr.functions.protocol.actors.ActorState state */ 2:
          message.state = ActorState.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.state
          )
          break
        case /* eigr.functions.protocol.actors.Metadata metadata */ 6:
          message.metadata = Metadata.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.metadata
          )
          break
        case /* eigr.functions.protocol.actors.ActorSettings settings */ 3:
          message.settings = ActorSettings.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.settings
          )
          break
        case /* repeated eigr.functions.protocol.actors.Command commands */ 4:
          message.commands.push(Command.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated eigr.functions.protocol.actors.FixedTimerCommand timer_commands */ 5:
          message.timerCommands.push(
            FixedTimerCommand.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Actor,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.actors.ActorId id = 1; */
    if (message.id)
      ActorId.internalBinaryWrite(
        message.id,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.ActorState state = 2; */
    if (message.state)
      ActorState.internalBinaryWrite(
        message.state,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.Metadata metadata = 6; */
    if (message.metadata)
      Metadata.internalBinaryWrite(
        message.metadata,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.ActorSettings settings = 3; */
    if (message.settings)
      ActorSettings.internalBinaryWrite(
        message.settings,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated eigr.functions.protocol.actors.Command commands = 4; */
    for (let i = 0; i < message.commands.length; i++)
      Command.internalBinaryWrite(
        message.commands[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated eigr.functions.protocol.actors.FixedTimerCommand timer_commands = 5; */
    for (let i = 0; i < message.timerCommands.length; i++)
      FixedTimerCommand.internalBinaryWrite(
        message.timerCommands[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.actors.Actor
 */
export const Actor = new Actor$Type()
