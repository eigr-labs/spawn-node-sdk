// @generated by protobuf-ts 2.7.0
// @generated from protobuf file "eigr/functions/protocol/actors/protocol.proto" (package "eigr.functions.protocol", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Actor } from "./actor";
import { Any } from "../../../../google/protobuf/any";
import { ActorSystem } from "./actor";
/**
 * @generated from protobuf message eigr.functions.protocol.RegistrationRequest
 */
export interface RegistrationRequest {
    /**
     * @generated from protobuf field: eigr.functions.protocol.ServiceInfo service_info = 1;
     */
    serviceInfo?: ServiceInfo;
    /**
     * @generated from protobuf field: eigr.functions.protocol.actors.ActorSystem actor_system = 2;
     */
    actorSystem?: ActorSystem;
}
/**
 * @generated from protobuf message eigr.functions.protocol.ServiceInfo
 */
export interface ServiceInfo {
    /**
     * The name of the actor system, eg, "my-actor-system".
     *
     * @generated from protobuf field: string service_name = 1;
     */
    serviceName: string;
    /**
     * The version of the service.
     *
     * @generated from protobuf field: string service_version = 2;
     */
    serviceVersion: string;
    /**
     * A description of the runtime for the service. Can be anything, but examples might be:
     * - node v10.15.2
     * - OpenJDK Runtime Environment 1.8.0_192-b12
     *
     * @generated from protobuf field: string service_runtime = 3;
     */
    serviceRuntime: string;
    /**
     * If using a support library, the name of that library, eg "spawn-jvm"
     *
     * @generated from protobuf field: string support_library_name = 4;
     */
    supportLibraryName: string;
    /**
     * The version of the support library being used.
     *
     * @generated from protobuf field: string support_library_version = 5;
     */
    supportLibraryVersion: string;
    /**
     * Spawn protocol major version accepted by the support library.
     *
     * @generated from protobuf field: int32 protocol_major_version = 6;
     */
    protocolMajorVersion: number;
    /**
     * Spawn protocol minor version accepted by the support library.
     *
     * @generated from protobuf field: int32 protocol_minor_version = 7;
     */
    protocolMinorVersion: number;
}
/**
 * @generated from protobuf message eigr.functions.protocol.ProxyInfo
 */
export interface ProxyInfo {
    /**
     * @generated from protobuf field: int32 protocol_major_version = 1;
     */
    protocolMajorVersion: number;
    /**
     * @generated from protobuf field: int32 protocol_minor_version = 2;
     */
    protocolMinorVersion: number;
    /**
     * @generated from protobuf field: string proxy_name = 3;
     */
    proxyName: string;
    /**
     * @generated from protobuf field: string proxy_version = 4;
     */
    proxyVersion: string;
}
/**
 * @generated from protobuf message eigr.functions.protocol.RegistrationResponse
 */
export interface RegistrationResponse {
    /**
     * @generated from protobuf field: eigr.functions.protocol.RequestStatus staus = 1;
     */
    staus?: RequestStatus;
    /**
     * @generated from protobuf field: eigr.functions.protocol.ProxyInfo proxy_info = 2;
     */
    proxyInfo?: ProxyInfo;
}
/**
 * Context is where current and/or updated state is stored
 * to be transmitted to/from proxy and user function
 *
 * Params:
 *   * state: Actor state passed back and forth between proxy and user function.
 *
 * @generated from protobuf message eigr.functions.protocol.Context
 */
export interface Context {
    /**
     * @generated from protobuf field: google.protobuf.Any state = 1;
     */
    state?: Any;
}
/**
 * The user function when it wants to send a message to an Actor uses the InvocationRequest message type.
 *
 * Params:
 *   * system: See ActorStstem message.
 *   * actor: The target Actor, i.e. the one that the user function is calling to perform some computation.
 *   * command_name: The function or method on the target Actor that will receive this request
 *     and perform some useful computation with the sent data.
 *   * value: This is the value sent by the user function to be computed by the request's target Actor command.
 *   * async: Indicates whether the command should be processed synchronously, where a response should be sent back to the user function,
 *            or whether the command should be processed asynchronously, i.e. no response sent to the caller and no waiting.
 *
 * @generated from protobuf message eigr.functions.protocol.InvocationRequest
 */
export interface InvocationRequest {
    /**
     * @generated from protobuf field: eigr.functions.protocol.actors.ActorSystem system = 1;
     */
    system?: ActorSystem;
    /**
     * @generated from protobuf field: eigr.functions.protocol.actors.Actor actor = 2;
     */
    actor?: Actor;
    /**
     * @generated from protobuf field: string command_name = 3;
     */
    commandName: string;
    /**
     * @generated from protobuf field: google.protobuf.Any value = 4;
     */
    value?: Any;
    /**
     * @generated from protobuf field: bool async = 5;
     */
    async: boolean;
}
/**
 * ActorInvocation is a translation message between a local invocation made via InvocationRequest
 * and the real Actor that intends to respond to this invocation and that can be located anywhere in the cluster.
 *
 * Params:
 *   actor_name: The name of the Actor handling the InvocationRequest request, also called the target Actor.
 *   actor_system: The name of ActorSystem registered in Registration step.
 *   command_name: The function or method on the target Actor that will receive this request
 *                 and perform some useful computation with the sent data.
 *   current_context: The current Context with current state value of the target Actor.
 *                    That is, the same as found via matching in %Actor{name: target_actor, state: %ActorState{state: value} = actor_state}.
 *                    In this case, the Context type will contain in the value attribute the same `value` as the matching above.
 *   value: The value to be passed to the function or method corresponding to command_name.
 *
 * @generated from protobuf message eigr.functions.protocol.ActorInvocation
 */
export interface ActorInvocation {
    /**
     * @generated from protobuf field: string actor_name = 1;
     */
    actorName: string;
    /**
     * @generated from protobuf field: string actor_system = 2;
     */
    actorSystem: string;
    /**
     * @generated from protobuf field: string command_name = 3;
     */
    commandName: string;
    /**
     * @generated from protobuf field: eigr.functions.protocol.Context current_context = 4;
     */
    currentContext?: Context;
    /**
     * @generated from protobuf field: google.protobuf.Any value = 5;
     */
    value?: Any;
}
/**
 * The user role's response after executing the action originated by the local proxy request via ActorInvocation.
 *
 * Params:
 *   actor_name: The name of the Actor handling the InvocationRequest request, also called the target Actor.
 *   actor_system: The name of ActorSystem registered in Registration step.
 *   updated_context: The Context with updated state value of the target Actor after user function has processed a request.
 *   value: The value that the original request proxy will forward in response to the InvocationRequest type request.
 *          This is the final response from the point of view of the user who invoked the Actor call and its subsequent processing.
 *
 * @generated from protobuf message eigr.functions.protocol.ActorInvocationResponse
 */
export interface ActorInvocationResponse {
    /**
     * @generated from protobuf field: string actor_name = 1;
     */
    actorName: string;
    /**
     * @generated from protobuf field: string actor_system = 2;
     */
    actorSystem: string;
    /**
     * @generated from protobuf field: eigr.functions.protocol.Context updated_context = 3;
     */
    updatedContext?: Context;
    /**
     * @generated from protobuf field: google.protobuf.Any value = 4;
     */
    value?: Any;
}
/**
 * InvocationResponse is the response that the proxy that received the InvocationRequest request will forward to the request's original user function.
 *
 * Params:
 *   status: Status of request. Could be one of [UNKNOWN, OK, ACTOR_NOT_FOUND, ERROR].
 *   sytem: The original ActorSystem of the InvocationRequest request.
 *   actor: The target Actor originally sent in the InvocationRequest message.
 *   value: The value resulting from the request processing that the target Actor made.
 *          This value must be passed by the user function to the one who requested the initial request in InvocationRequest.
 *
 * @generated from protobuf message eigr.functions.protocol.InvocationResponse
 */
export interface InvocationResponse {
    /**
     * @generated from protobuf field: eigr.functions.protocol.RequestStatus status = 1;
     */
    status?: RequestStatus;
    /**
     * @generated from protobuf field: eigr.functions.protocol.actors.ActorSystem system = 2;
     */
    system?: ActorSystem;
    /**
     * @generated from protobuf field: eigr.functions.protocol.actors.Actor actor = 3;
     */
    actor?: Actor;
    /**
     * @generated from protobuf field: google.protobuf.Any value = 4;
     */
    value?: Any;
}
/**
 * @generated from protobuf message eigr.functions.protocol.RequestStatus
 */
export interface RequestStatus {
    /**
     * @generated from protobuf field: eigr.functions.protocol.Status status = 1;
     */
    status: Status;
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
}
/**
 * @generated from protobuf enum eigr.functions.protocol.Status
 */
export enum Status {
    /**
     * @generated from protobuf enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: OK = 1;
     */
    OK = 1,
    /**
     * @generated from protobuf enum value: ACTOR_NOT_FOUND = 2;
     */
    ACTOR_NOT_FOUND = 2,
    /**
     * @generated from protobuf enum value: ERROR = 3;
     */
    ERROR = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class RegistrationRequest$Type extends MessageType<RegistrationRequest> {
    constructor() {
        super("eigr.functions.protocol.RegistrationRequest", [
            { no: 1, name: "service_info", kind: "message", T: () => ServiceInfo },
            { no: 2, name: "actor_system", kind: "message", T: () => ActorSystem }
        ]);
    }
    create(value?: PartialMessage<RegistrationRequest>): RegistrationRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegistrationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegistrationRequest): RegistrationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eigr.functions.protocol.ServiceInfo service_info */ 1:
                    message.serviceInfo = ServiceInfo.internalBinaryRead(reader, reader.uint32(), options, message.serviceInfo);
                    break;
                case /* eigr.functions.protocol.actors.ActorSystem actor_system */ 2:
                    message.actorSystem = ActorSystem.internalBinaryRead(reader, reader.uint32(), options, message.actorSystem);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegistrationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eigr.functions.protocol.ServiceInfo service_info = 1; */
        if (message.serviceInfo)
            ServiceInfo.internalBinaryWrite(message.serviceInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eigr.functions.protocol.actors.ActorSystem actor_system = 2; */
        if (message.actorSystem)
            ActorSystem.internalBinaryWrite(message.actorSystem, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.RegistrationRequest
 */
export const RegistrationRequest = new RegistrationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceInfo$Type extends MessageType<ServiceInfo> {
    constructor() {
        super("eigr.functions.protocol.ServiceInfo", [
            { no: 1, name: "service_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "service_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "service_runtime", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "support_library_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "support_library_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "protocol_major_version", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "protocol_minor_version", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ServiceInfo>): ServiceInfo {
        const message = { serviceName: "", serviceVersion: "", serviceRuntime: "", supportLibraryName: "", supportLibraryVersion: "", protocolMajorVersion: 0, protocolMinorVersion: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ServiceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceInfo): ServiceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_name */ 1:
                    message.serviceName = reader.string();
                    break;
                case /* string service_version */ 2:
                    message.serviceVersion = reader.string();
                    break;
                case /* string service_runtime */ 3:
                    message.serviceRuntime = reader.string();
                    break;
                case /* string support_library_name */ 4:
                    message.supportLibraryName = reader.string();
                    break;
                case /* string support_library_version */ 5:
                    message.supportLibraryVersion = reader.string();
                    break;
                case /* int32 protocol_major_version */ 6:
                    message.protocolMajorVersion = reader.int32();
                    break;
                case /* int32 protocol_minor_version */ 7:
                    message.protocolMinorVersion = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_name = 1; */
        if (message.serviceName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceName);
        /* string service_version = 2; */
        if (message.serviceVersion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.serviceVersion);
        /* string service_runtime = 3; */
        if (message.serviceRuntime !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serviceRuntime);
        /* string support_library_name = 4; */
        if (message.supportLibraryName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.supportLibraryName);
        /* string support_library_version = 5; */
        if (message.supportLibraryVersion !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.supportLibraryVersion);
        /* int32 protocol_major_version = 6; */
        if (message.protocolMajorVersion !== 0)
            writer.tag(6, WireType.Varint).int32(message.protocolMajorVersion);
        /* int32 protocol_minor_version = 7; */
        if (message.protocolMinorVersion !== 0)
            writer.tag(7, WireType.Varint).int32(message.protocolMinorVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.ServiceInfo
 */
export const ServiceInfo = new ServiceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProxyInfo$Type extends MessageType<ProxyInfo> {
    constructor() {
        super("eigr.functions.protocol.ProxyInfo", [
            { no: 1, name: "protocol_major_version", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "protocol_minor_version", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "proxy_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "proxy_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ProxyInfo>): ProxyInfo {
        const message = { protocolMajorVersion: 0, protocolMinorVersion: 0, proxyName: "", proxyVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProxyInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProxyInfo): ProxyInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 protocol_major_version */ 1:
                    message.protocolMajorVersion = reader.int32();
                    break;
                case /* int32 protocol_minor_version */ 2:
                    message.protocolMinorVersion = reader.int32();
                    break;
                case /* string proxy_name */ 3:
                    message.proxyName = reader.string();
                    break;
                case /* string proxy_version */ 4:
                    message.proxyVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProxyInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 protocol_major_version = 1; */
        if (message.protocolMajorVersion !== 0)
            writer.tag(1, WireType.Varint).int32(message.protocolMajorVersion);
        /* int32 protocol_minor_version = 2; */
        if (message.protocolMinorVersion !== 0)
            writer.tag(2, WireType.Varint).int32(message.protocolMinorVersion);
        /* string proxy_name = 3; */
        if (message.proxyName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.proxyName);
        /* string proxy_version = 4; */
        if (message.proxyVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.proxyVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.ProxyInfo
 */
export const ProxyInfo = new ProxyInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegistrationResponse$Type extends MessageType<RegistrationResponse> {
    constructor() {
        super("eigr.functions.protocol.RegistrationResponse", [
            { no: 1, name: "staus", kind: "message", T: () => RequestStatus },
            { no: 2, name: "proxy_info", kind: "message", T: () => ProxyInfo }
        ]);
    }
    create(value?: PartialMessage<RegistrationResponse>): RegistrationResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegistrationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegistrationResponse): RegistrationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eigr.functions.protocol.RequestStatus staus */ 1:
                    message.staus = RequestStatus.internalBinaryRead(reader, reader.uint32(), options, message.staus);
                    break;
                case /* eigr.functions.protocol.ProxyInfo proxy_info */ 2:
                    message.proxyInfo = ProxyInfo.internalBinaryRead(reader, reader.uint32(), options, message.proxyInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegistrationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eigr.functions.protocol.RequestStatus staus = 1; */
        if (message.staus)
            RequestStatus.internalBinaryWrite(message.staus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eigr.functions.protocol.ProxyInfo proxy_info = 2; */
        if (message.proxyInfo)
            ProxyInfo.internalBinaryWrite(message.proxyInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.RegistrationResponse
 */
export const RegistrationResponse = new RegistrationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Context$Type extends MessageType<Context> {
    constructor() {
        super("eigr.functions.protocol.Context", [
            { no: 1, name: "state", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<Context>): Context {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Context>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Context): Context {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any state */ 1:
                    message.state = Any.internalBinaryRead(reader, reader.uint32(), options, message.state);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Context, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any state = 1; */
        if (message.state)
            Any.internalBinaryWrite(message.state, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.Context
 */
export const Context = new Context$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InvocationRequest$Type extends MessageType<InvocationRequest> {
    constructor() {
        super("eigr.functions.protocol.InvocationRequest", [
            { no: 1, name: "system", kind: "message", T: () => ActorSystem },
            { no: 2, name: "actor", kind: "message", T: () => Actor },
            { no: 3, name: "command_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value", kind: "message", T: () => Any },
            { no: 5, name: "async", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<InvocationRequest>): InvocationRequest {
        const message = { commandName: "", async: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InvocationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvocationRequest): InvocationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eigr.functions.protocol.actors.ActorSystem system */ 1:
                    message.system = ActorSystem.internalBinaryRead(reader, reader.uint32(), options, message.system);
                    break;
                case /* eigr.functions.protocol.actors.Actor actor */ 2:
                    message.actor = Actor.internalBinaryRead(reader, reader.uint32(), options, message.actor);
                    break;
                case /* string command_name */ 3:
                    message.commandName = reader.string();
                    break;
                case /* google.protobuf.Any value */ 4:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* bool async */ 5:
                    message.async = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InvocationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eigr.functions.protocol.actors.ActorSystem system = 1; */
        if (message.system)
            ActorSystem.internalBinaryWrite(message.system, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eigr.functions.protocol.actors.Actor actor = 2; */
        if (message.actor)
            Actor.internalBinaryWrite(message.actor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string command_name = 3; */
        if (message.commandName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.commandName);
        /* google.protobuf.Any value = 4; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool async = 5; */
        if (message.async !== false)
            writer.tag(5, WireType.Varint).bool(message.async);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.InvocationRequest
 */
export const InvocationRequest = new InvocationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActorInvocation$Type extends MessageType<ActorInvocation> {
    constructor() {
        super("eigr.functions.protocol.ActorInvocation", [
            { no: 1, name: "actor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "actor_system", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "command_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "current_context", kind: "message", T: () => Context },
            { no: 5, name: "value", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ActorInvocation>): ActorInvocation {
        const message = { actorName: "", actorSystem: "", commandName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActorInvocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActorInvocation): ActorInvocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string actor_name */ 1:
                    message.actorName = reader.string();
                    break;
                case /* string actor_system */ 2:
                    message.actorSystem = reader.string();
                    break;
                case /* string command_name */ 3:
                    message.commandName = reader.string();
                    break;
                case /* eigr.functions.protocol.Context current_context */ 4:
                    message.currentContext = Context.internalBinaryRead(reader, reader.uint32(), options, message.currentContext);
                    break;
                case /* google.protobuf.Any value */ 5:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActorInvocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string actor_name = 1; */
        if (message.actorName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.actorName);
        /* string actor_system = 2; */
        if (message.actorSystem !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.actorSystem);
        /* string command_name = 3; */
        if (message.commandName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.commandName);
        /* eigr.functions.protocol.Context current_context = 4; */
        if (message.currentContext)
            Context.internalBinaryWrite(message.currentContext, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any value = 5; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.ActorInvocation
 */
export const ActorInvocation = new ActorInvocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActorInvocationResponse$Type extends MessageType<ActorInvocationResponse> {
    constructor() {
        super("eigr.functions.protocol.ActorInvocationResponse", [
            { no: 1, name: "actor_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "actor_system", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updated_context", kind: "message", T: () => Context },
            { no: 4, name: "value", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ActorInvocationResponse>): ActorInvocationResponse {
        const message = { actorName: "", actorSystem: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActorInvocationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActorInvocationResponse): ActorInvocationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string actor_name */ 1:
                    message.actorName = reader.string();
                    break;
                case /* string actor_system */ 2:
                    message.actorSystem = reader.string();
                    break;
                case /* eigr.functions.protocol.Context updated_context */ 3:
                    message.updatedContext = Context.internalBinaryRead(reader, reader.uint32(), options, message.updatedContext);
                    break;
                case /* google.protobuf.Any value */ 4:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActorInvocationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string actor_name = 1; */
        if (message.actorName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.actorName);
        /* string actor_system = 2; */
        if (message.actorSystem !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.actorSystem);
        /* eigr.functions.protocol.Context updated_context = 3; */
        if (message.updatedContext)
            Context.internalBinaryWrite(message.updatedContext, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any value = 4; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.ActorInvocationResponse
 */
export const ActorInvocationResponse = new ActorInvocationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InvocationResponse$Type extends MessageType<InvocationResponse> {
    constructor() {
        super("eigr.functions.protocol.InvocationResponse", [
            { no: 1, name: "status", kind: "message", T: () => RequestStatus },
            { no: 2, name: "system", kind: "message", T: () => ActorSystem },
            { no: 3, name: "actor", kind: "message", T: () => Actor },
            { no: 4, name: "value", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<InvocationResponse>): InvocationResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InvocationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvocationResponse): InvocationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eigr.functions.protocol.RequestStatus status */ 1:
                    message.status = RequestStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* eigr.functions.protocol.actors.ActorSystem system */ 2:
                    message.system = ActorSystem.internalBinaryRead(reader, reader.uint32(), options, message.system);
                    break;
                case /* eigr.functions.protocol.actors.Actor actor */ 3:
                    message.actor = Actor.internalBinaryRead(reader, reader.uint32(), options, message.actor);
                    break;
                case /* google.protobuf.Any value */ 4:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InvocationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eigr.functions.protocol.RequestStatus status = 1; */
        if (message.status)
            RequestStatus.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* eigr.functions.protocol.actors.ActorSystem system = 2; */
        if (message.system)
            ActorSystem.internalBinaryWrite(message.system, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* eigr.functions.protocol.actors.Actor actor = 3; */
        if (message.actor)
            Actor.internalBinaryWrite(message.actor, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any value = 4; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.InvocationResponse
 */
export const InvocationResponse = new InvocationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestStatus$Type extends MessageType<RequestStatus> {
    constructor() {
        super("eigr.functions.protocol.RequestStatus", [
            { no: 1, name: "status", kind: "enum", T: () => ["eigr.functions.protocol.Status", Status] },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestStatus>): RequestStatus {
        const message = { status: 0, message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RequestStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestStatus): RequestStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eigr.functions.protocol.Status status */ 1:
                    message.status = reader.int32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eigr.functions.protocol.Status status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.RequestStatus
 */
export const RequestStatus = new RequestStatus$Type();
