// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "protocol.proto" (package "eigr.functions.protocol", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MESSAGE_TYPE } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Actor } from './actor'
import { ActorSystem } from './actor'
import { ActorId } from './actor'
import { Any } from '../../../../google/any'
/**
 * Context is where current and/or updated state is stored
 * to be transmitted to/from proxy and user function
 *
 * Params:
 *   * state: Actor state passed back and forth between proxy and user function.
 *   * metadata: Meta information that comes in invocations
 *   * tags: Meta information stored in the actor
 *   * caller: ActorId of who is calling target actor
 *   * self: ActorId of itself
 *
 * @generated from protobuf message eigr.functions.protocol.Context
 */
export interface Context {
  /**
   * @generated from protobuf field: google.protobuf.Any state = 1;
   */
  state?: Any
  /**
   * @generated from protobuf field: map<string, string> metadata = 4;
   */
  metadata: {
    [key: string]: string
  }
  /**
   * @generated from protobuf field: map<string, string> tags = 5;
   */
  tags: {
    [key: string]: string
  }
  /**
   * Who is calling target actor
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorId caller = 2;
   */
  caller?: ActorId
  /**
   * The target actor itself
   *
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorId self = 3;
   */
  self?: ActorId
}
/**
 * Noop is used when the input or output value of a function or method
 * does not matter to the caller of a Workflow or when the user just wants to receive
 * the Context in the request, that is,
 * he does not care about the input value only with the state.
 *
 * @generated from protobuf message eigr.functions.protocol.Noop
 */
export interface Noop {}
/**
 * @generated from protobuf message eigr.functions.protocol.RegistrationRequest
 */
export interface RegistrationRequest {
  /**
   * @generated from protobuf field: eigr.functions.protocol.ServiceInfo service_info = 1;
   */
  serviceInfo?: ServiceInfo
  /**
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorSystem actor_system = 2;
   */
  actorSystem?: ActorSystem
}
/**
 * @generated from protobuf message eigr.functions.protocol.RegistrationResponse
 */
export interface RegistrationResponse {
  /**
   * @generated from protobuf field: eigr.functions.protocol.RequestStatus status = 1;
   */
  status?: RequestStatus
  /**
   * @generated from protobuf field: eigr.functions.protocol.ProxyInfo proxy_info = 2;
   */
  proxyInfo?: ProxyInfo
}
/**
 * @generated from protobuf message eigr.functions.protocol.ServiceInfo
 */
export interface ServiceInfo {
  /**
   * The name of the actor system, eg, "my-actor-system".
   *
   * @generated from protobuf field: string service_name = 1;
   */
  serviceName: string
  /**
   * The version of the service.
   *
   * @generated from protobuf field: string service_version = 2;
   */
  serviceVersion: string
  /**
   * A description of the runtime for the service. Can be anything, but examples might be:
   * - node v10.15.2
   * - OpenJDK Runtime Environment 1.8.0_192-b12
   *
   * @generated from protobuf field: string service_runtime = 3;
   */
  serviceRuntime: string
  /**
   * If using a support library, the name of that library, eg "spawn-jvm"
   *
   * @generated from protobuf field: string support_library_name = 4;
   */
  supportLibraryName: string
  /**
   * The version of the support library being used.
   *
   * @generated from protobuf field: string support_library_version = 5;
   */
  supportLibraryVersion: string
  /**
   * Spawn protocol major version accepted by the support library.
   *
   * @generated from protobuf field: int32 protocol_major_version = 6;
   */
  protocolMajorVersion: number
  /**
   * Spawn protocol minor version accepted by the support library.
   *
   * @generated from protobuf field: int32 protocol_minor_version = 7;
   */
  protocolMinorVersion: number
}
/**
 * @generated from protobuf message eigr.functions.protocol.SpawnRequest
 */
export interface SpawnRequest {
  /**
   * @generated from protobuf field: repeated eigr.functions.protocol.actors.ActorId actors = 1;
   */
  actors: ActorId[]
}
/**
 * @generated from protobuf message eigr.functions.protocol.SpawnResponse
 */
export interface SpawnResponse {
  /**
   * @generated from protobuf field: eigr.functions.protocol.RequestStatus status = 1;
   */
  status?: RequestStatus
}
/**
 * @generated from protobuf message eigr.functions.protocol.ProxyInfo
 */
export interface ProxyInfo {
  /**
   * @generated from protobuf field: int32 protocol_major_version = 1;
   */
  protocolMajorVersion: number
  /**
   * @generated from protobuf field: int32 protocol_minor_version = 2;
   */
  protocolMinorVersion: number
  /**
   * @generated from protobuf field: string proxy_name = 3;
   */
  proxyName: string
  /**
   * @generated from protobuf field: string proxy_version = 4;
   */
  proxyVersion: string
}
/**
 * When a Host Function is invoked it returns the updated state and return value to the call.
 * It can also return a number of side effects to other Actors as a result of its computation.
 * These side effects will be forwarded to the respective Actors asynchronously and should not affect the Host Function's response to its caller.
 * Internally side effects is just a special kind of InvocationRequest.
 * Useful for handle handle `recipient list` and `Composed Message Processor` patterns:
 * https://www.enterpriseintegrationpatterns.com/patterns/messaging/RecipientList.html
 * https://www.enterpriseintegrationpatterns.com/patterns/messaging/DistributionAggregate.html
 *
 * @generated from protobuf message eigr.functions.protocol.SideEffect
 */
export interface SideEffect {
  /**
   * @generated from protobuf field: eigr.functions.protocol.InvocationRequest request = 1;
   */
  request?: InvocationRequest
}
/**
 * Broadcast a message to many Actors
 * Useful for handle `recipient list`, `publish-subscribe channel`, and `scatter-gatther` patterns:
 * https://www.enterpriseintegrationpatterns.com/patterns/messaging/RecipientList.html
 * https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html
 * https://www.enterpriseintegrationpatterns.com/patterns/messaging/BroadcastAggregate.html
 *
 * @generated from protobuf message eigr.functions.protocol.Broadcast
 */
export interface Broadcast {
  /**
   * Channel of target Actors
   *
   * @generated from protobuf field: string channel_group = 1;
   */
  channelGroup: string
  /**
   * Command. Only Actors that have this command will run successfully
   *
   * @generated from protobuf field: string command_name = 2;
   */
  commandName: string
  /**
   * @generated from protobuf oneof: payload
   */
  payload:
    | {
        oneofKind: 'value'
        /**
         * @generated from protobuf field: google.protobuf.Any value = 3;
         */
        value: Any
      }
    | {
        oneofKind: 'noop'
        /**
         * @generated from protobuf field: eigr.functions.protocol.Noop noop = 4;
         */
        noop: Noop
      }
    | {
        oneofKind: undefined
      }
}
/**
 * Sends the output of a command of an Actor to the input of another command of an Actor
 * Useful for handle `pipes` pattern:
 * https://www.enterpriseintegrationpatterns.com/patterns/messaging/PipesAndFilters.html
 *
 * @generated from protobuf message eigr.functions.protocol.Pipe
 */
export interface Pipe {
  /**
   * Target Actor
   *
   * @generated from protobuf field: string actor = 1;
   */
  actor: string
  /**
   * Command.
   *
   * @generated from protobuf field: string command_name = 2;
   */
  commandName: string
}
/**
 * Sends the input of a command of an Actor to the input of another command of an Actor
 * Useful for handle `content-basead router` pattern
 * https://www.enterpriseintegrationpatterns.com/patterns/messaging/ContentBasedRouter.html
 *
 * @generated from protobuf message eigr.functions.protocol.Forward
 */
export interface Forward {
  /**
   * Target Actor
   *
   * @generated from protobuf field: string actor = 1;
   */
  actor: string
  /**
   * Command.
   *
   * @generated from protobuf field: string command_name = 2;
   */
  commandName: string
}
/**
 * Container for archicetural message patterns
 *
 * @generated from protobuf message eigr.functions.protocol.Workflow
 */
export interface Workflow {
  /**
   * @generated from protobuf field: eigr.functions.protocol.Broadcast broadcast = 2;
   */
  broadcast?: Broadcast
  /**
   * @generated from protobuf field: repeated eigr.functions.protocol.SideEffect effects = 1;
   */
  effects: SideEffect[]
  /**
   * @generated from protobuf oneof: routing
   */
  routing:
    | {
        oneofKind: 'pipe'
        /**
         * @generated from protobuf field: eigr.functions.protocol.Pipe pipe = 3;
         */
        pipe: Pipe
      }
    | {
        oneofKind: 'forward'
        /**
         * @generated from protobuf field: eigr.functions.protocol.Forward forward = 4;
         */
        forward: Forward
      }
    | {
        oneofKind: undefined
      }
}
/**
 * The user function when it wants to send a message to an Actor uses the InvocationRequest message type.
 *
 * Params:
 *   * system: See ActorSystem message.
 *   * actor: The target Actor, i.e. the one that the user function is calling to perform some computation.
 *   * caller: The caller Actor
 *   * command_name: The function or method on the target Actor that will receive this request
 *     and perform some useful computation with the sent data.
 *   * value: This is the value sent by the user function to be computed by the request's target Actor command.
 *   * async: Indicates whether the command should be processed synchronously, where a response should be sent back to the user function,
 *            or whether the command should be processed asynchronously, i.e. no response sent to the caller and no waiting.
 *   * metadata: Meta information or headers
 *
 * @generated from protobuf message eigr.functions.protocol.InvocationRequest
 */
export interface InvocationRequest {
  /**
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorSystem system = 1;
   */
  system?: ActorSystem
  /**
   * @generated from protobuf field: eigr.functions.protocol.actors.Actor actor = 2;
   */
  actor?: Actor
  /**
   * @generated from protobuf field: string command_name = 3;
   */
  commandName: string
  /**
   * @generated from protobuf oneof: payload
   */
  payload:
    | {
        oneofKind: 'value'
        /**
         * @generated from protobuf field: google.protobuf.Any value = 4;
         */
        value: Any
      }
    | {
        oneofKind: 'noop'
        /**
         * @generated from protobuf field: eigr.functions.protocol.Noop noop = 7;
         */
        noop: Noop
      }
    | {
        oneofKind: undefined
      }
  /**
   * @generated from protobuf field: bool async = 5;
   */
  async: boolean
  /**
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorId caller = 6;
   */
  caller?: ActorId
  /**
   * @generated from protobuf field: map<string, string> metadata = 8;
   */
  metadata: {
    [key: string]: string
  }
  /**
   * @generated from protobuf field: int64 scheduled_to = 9;
   */
  scheduledTo: bigint
  /**
   * @generated from protobuf field: bool pooled = 10;
   */
  pooled: boolean
}
/**
 * ActorInvocation is a translation message between a local invocation made via InvocationRequest
 * and the real Actor that intends to respond to this invocation and that can be located anywhere in the cluster.
 *
 * Params:
 *   * actor: The ActorId handling the InvocationRequest request, also called the target Actor.
 *   * command_name: The function or method on the target Actor that will receive this request
 *                 and perform some useful computation with the sent data.
 *   * current_context: The current Context with current state value of the target Actor.
 *                    That is, the same as found via matching in %Actor{name: target_actor, state: %ActorState{state: value} = actor_state}.
 *                    In this case, the Context type will contain in the value attribute the same `value` as the matching above.
 *   * payload: The value to be passed to the function or method corresponding to command_name.
 *
 * @generated from protobuf message eigr.functions.protocol.ActorInvocation
 */
export interface ActorInvocation {
  /**
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorId actor = 1;
   */
  actor?: ActorId
  /**
   * @generated from protobuf field: string command_name = 2;
   */
  commandName: string
  /**
   * @generated from protobuf field: eigr.functions.protocol.Context current_context = 3;
   */
  currentContext?: Context
  /**
   * @generated from protobuf oneof: payload
   */
  payload:
    | {
        oneofKind: 'value'
        /**
         * @generated from protobuf field: google.protobuf.Any value = 4;
         */
        value: Any
      }
    | {
        oneofKind: 'noop'
        /**
         * @generated from protobuf field: eigr.functions.protocol.Noop noop = 5;
         */
        noop: Noop
      }
    | {
        oneofKind: undefined
      }
  /**
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorId caller = 6;
   */
  caller?: ActorId
}
/**
 * The user function's response after executing the action originated by the local proxy request via ActorInvocation.
 *
 * Params:
 *   actor_name: The name of the Actor handling the InvocationRequest request, also called the target Actor.
 *   actor_system: The name of ActorSystem registered in Registration step.
 *   updated_context: The Context with updated state value of the target Actor after user function has processed a request.
 *   value: The value that the original request proxy will forward in response to the InvocationRequest type request.
 *          This is the final response from the point of view of the user who invoked the Actor call and its subsequent processing.
 *
 * @generated from protobuf message eigr.functions.protocol.ActorInvocationResponse
 */
export interface ActorInvocationResponse {
  /**
   * @generated from protobuf field: string actor_name = 1;
   */
  actorName: string
  /**
   * @generated from protobuf field: string actor_system = 2;
   */
  actorSystem: string
  /**
   * @generated from protobuf field: eigr.functions.protocol.Context updated_context = 3;
   */
  updatedContext?: Context
  /**
   * @generated from protobuf oneof: payload
   */
  payload:
    | {
        oneofKind: 'value'
        /**
         * @generated from protobuf field: google.protobuf.Any value = 4;
         */
        value: Any
      }
    | {
        oneofKind: 'noop'
        /**
         * @generated from protobuf field: eigr.functions.protocol.Noop noop = 6;
         */
        noop: Noop
      }
    | {
        oneofKind: undefined
      }
  /**
   * @generated from protobuf field: eigr.functions.protocol.Workflow workflow = 5;
   */
  workflow?: Workflow
}
/**
 * InvocationResponse is the response that the proxy that received the InvocationRequest request will forward to the request's original user function.
 *
 * Params:
 *   status: Status of request. Could be one of [UNKNOWN, OK, ACTOR_NOT_FOUND, ERROR].
 *   system: The original ActorSystem of the InvocationRequest request.
 *   actor: The target Actor originally sent in the InvocationRequest message.
 *   value: The value resulting from the request processing that the target Actor made.
 *          This value must be passed by the user function to the one who requested the initial request in InvocationRequest.
 *
 * @generated from protobuf message eigr.functions.protocol.InvocationResponse
 */
export interface InvocationResponse {
  /**
   * @generated from protobuf field: eigr.functions.protocol.RequestStatus status = 1;
   */
  status?: RequestStatus
  /**
   * @generated from protobuf field: eigr.functions.protocol.actors.ActorSystem system = 2;
   */
  system?: ActorSystem
  /**
   * @generated from protobuf field: eigr.functions.protocol.actors.Actor actor = 3;
   */
  actor?: Actor
  /**
   * @generated from protobuf oneof: payload
   */
  payload:
    | {
        oneofKind: 'value'
        /**
         * @generated from protobuf field: google.protobuf.Any value = 4;
         */
        value: Any
      }
    | {
        oneofKind: 'noop'
        /**
         * @generated from protobuf field: eigr.functions.protocol.Noop noop = 5;
         */
        noop: Noop
      }
    | {
        oneofKind: undefined
      }
}
/**
 * @generated from protobuf message eigr.functions.protocol.RequestStatus
 */
export interface RequestStatus {
  /**
   * @generated from protobuf field: eigr.functions.protocol.Status status = 1;
   */
  status: Status
  /**
   * @generated from protobuf field: string message = 2;
   */
  message: string
}
/**
 * @generated from protobuf enum eigr.functions.protocol.Status
 */
export enum Status {
  /**
   * @generated from protobuf enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,
  /**
   * @generated from protobuf enum value: OK = 1;
   */
  OK = 1,
  /**
   * @generated from protobuf enum value: ACTOR_NOT_FOUND = 2;
   */
  ACTOR_NOT_FOUND = 2,
  /**
   * @generated from protobuf enum value: ERROR = 3;
   */
  ERROR = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Context$Type extends MessageType<Context> {
  constructor() {
    super('eigr.functions.protocol.Context', [
      { no: 1, name: 'state', kind: 'message', T: () => Any },
      {
        no: 4,
        name: 'metadata',
        kind: 'map',
        K: 9 /*ScalarType.STRING*/,
        V: { kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
      },
      {
        no: 5,
        name: 'tags',
        kind: 'map',
        K: 9 /*ScalarType.STRING*/,
        V: { kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
      },
      { no: 2, name: 'caller', kind: 'message', T: () => ActorId },
      { no: 3, name: 'self', kind: 'message', T: () => ActorId }
    ])
  }
  create(value?: PartialMessage<Context>): Context {
    const message = { metadata: {}, tags: {} }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Context>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Context
  ): Context {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* google.protobuf.Any state */ 1:
          message.state = Any.internalBinaryRead(reader, reader.uint32(), options, message.state)
          break
        case /* map<string, string> metadata */ 4:
          this.binaryReadMap4(message.metadata, reader, options)
          break
        case /* map<string, string> tags */ 5:
          this.binaryReadMap5(message.tags, reader, options)
          break
        case /* eigr.functions.protocol.actors.ActorId caller */ 2:
          message.caller = ActorId.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.caller
          )
          break
        case /* eigr.functions.protocol.actors.ActorId self */ 3:
          message.self = ActorId.internalBinaryRead(reader, reader.uint32(), options, message.self)
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  private binaryReadMap4(
    map: Context['metadata'],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof Context['metadata'] | undefined,
      val: Context['metadata'][any] | undefined
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case 1:
          key = reader.string()
          break
        case 2:
          val = reader.string()
          break
        default:
          throw new globalThis.Error(
            'unknown map entry field for field eigr.functions.protocol.Context.metadata'
          )
      }
    }
    map[key ?? ''] = val ?? ''
  }
  private binaryReadMap5(
    map: Context['tags'],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof Context['tags'] | undefined,
      val: Context['tags'][any] | undefined
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case 1:
          key = reader.string()
          break
        case 2:
          val = reader.string()
          break
        default:
          throw new globalThis.Error(
            'unknown map entry field for field eigr.functions.protocol.Context.tags'
          )
      }
    }
    map[key ?? ''] = val ?? ''
  }
  internalBinaryWrite(
    message: Context,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* google.protobuf.Any state = 1; */
    if (message.state)
      Any.internalBinaryWrite(
        message.state,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* map<string, string> metadata = 4; */
    for (let k of Object.keys(message.metadata))
      writer
        .tag(4, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.LengthDelimited)
        .string(message.metadata[k])
        .join()
    /* map<string, string> tags = 5; */
    for (let k of Object.keys(message.tags))
      writer
        .tag(5, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.LengthDelimited)
        .string(message.tags[k])
        .join()
    /* eigr.functions.protocol.actors.ActorId caller = 2; */
    if (message.caller)
      ActorId.internalBinaryWrite(
        message.caller,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.ActorId self = 3; */
    if (message.self)
      ActorId.internalBinaryWrite(
        message.self,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.Context
 */
export const Context = new Context$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Noop$Type extends MessageType<Noop> {
  constructor() {
    super('eigr.functions.protocol.Noop', [])
  }
  create(value?: PartialMessage<Noop>): Noop {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Noop>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Noop
  ): Noop {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: Noop,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.Noop
 */
export const Noop = new Noop$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RegistrationRequest$Type extends MessageType<RegistrationRequest> {
  constructor() {
    super('eigr.functions.protocol.RegistrationRequest', [
      { no: 1, name: 'service_info', kind: 'message', T: () => ServiceInfo },
      { no: 2, name: 'actor_system', kind: 'message', T: () => ActorSystem }
    ])
  }
  create(value?: PartialMessage<RegistrationRequest>): RegistrationRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<RegistrationRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RegistrationRequest
  ): RegistrationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.ServiceInfo service_info */ 1:
          message.serviceInfo = ServiceInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.serviceInfo
          )
          break
        case /* eigr.functions.protocol.actors.ActorSystem actor_system */ 2:
          message.actorSystem = ActorSystem.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.actorSystem
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RegistrationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.ServiceInfo service_info = 1; */
    if (message.serviceInfo)
      ServiceInfo.internalBinaryWrite(
        message.serviceInfo,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.ActorSystem actor_system = 2; */
    if (message.actorSystem)
      ActorSystem.internalBinaryWrite(
        message.actorSystem,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.RegistrationRequest
 */
export const RegistrationRequest = new RegistrationRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RegistrationResponse$Type extends MessageType<RegistrationResponse> {
  constructor() {
    super('eigr.functions.protocol.RegistrationResponse', [
      { no: 1, name: 'status', kind: 'message', T: () => RequestStatus },
      { no: 2, name: 'proxy_info', kind: 'message', T: () => ProxyInfo }
    ])
  }
  create(value?: PartialMessage<RegistrationResponse>): RegistrationResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<RegistrationResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RegistrationResponse
  ): RegistrationResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.RequestStatus status */ 1:
          message.status = RequestStatus.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.status
          )
          break
        case /* eigr.functions.protocol.ProxyInfo proxy_info */ 2:
          message.proxyInfo = ProxyInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.proxyInfo
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RegistrationResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.RequestStatus status = 1; */
    if (message.status)
      RequestStatus.internalBinaryWrite(
        message.status,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.ProxyInfo proxy_info = 2; */
    if (message.proxyInfo)
      ProxyInfo.internalBinaryWrite(
        message.proxyInfo,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.RegistrationResponse
 */
export const RegistrationResponse = new RegistrationResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ServiceInfo$Type extends MessageType<ServiceInfo> {
  constructor() {
    super('eigr.functions.protocol.ServiceInfo', [
      { no: 1, name: 'service_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'service_version', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'service_runtime', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'support_library_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'support_library_version', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'protocol_major_version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 7, name: 'protocol_minor_version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<ServiceInfo>): ServiceInfo {
    const message = {
      serviceName: '',
      serviceVersion: '',
      serviceRuntime: '',
      supportLibraryName: '',
      supportLibraryVersion: '',
      protocolMajorVersion: 0,
      protocolMinorVersion: 0
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ServiceInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServiceInfo
  ): ServiceInfo {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string service_name */ 1:
          message.serviceName = reader.string()
          break
        case /* string service_version */ 2:
          message.serviceVersion = reader.string()
          break
        case /* string service_runtime */ 3:
          message.serviceRuntime = reader.string()
          break
        case /* string support_library_name */ 4:
          message.supportLibraryName = reader.string()
          break
        case /* string support_library_version */ 5:
          message.supportLibraryVersion = reader.string()
          break
        case /* int32 protocol_major_version */ 6:
          message.protocolMajorVersion = reader.int32()
          break
        case /* int32 protocol_minor_version */ 7:
          message.protocolMinorVersion = reader.int32()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ServiceInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string service_name = 1; */
    if (message.serviceName !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.serviceName)
    /* string service_version = 2; */
    if (message.serviceVersion !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.serviceVersion)
    /* string service_runtime = 3; */
    if (message.serviceRuntime !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.serviceRuntime)
    /* string support_library_name = 4; */
    if (message.supportLibraryName !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.supportLibraryName)
    /* string support_library_version = 5; */
    if (message.supportLibraryVersion !== '')
      writer.tag(5, WireType.LengthDelimited).string(message.supportLibraryVersion)
    /* int32 protocol_major_version = 6; */
    if (message.protocolMajorVersion !== 0)
      writer.tag(6, WireType.Varint).int32(message.protocolMajorVersion)
    /* int32 protocol_minor_version = 7; */
    if (message.protocolMinorVersion !== 0)
      writer.tag(7, WireType.Varint).int32(message.protocolMinorVersion)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.ServiceInfo
 */
export const ServiceInfo = new ServiceInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SpawnRequest$Type extends MessageType<SpawnRequest> {
  constructor() {
    super('eigr.functions.protocol.SpawnRequest', [
      { no: 1, name: 'actors', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => ActorId }
    ])
  }
  create(value?: PartialMessage<SpawnRequest>): SpawnRequest {
    const message = { actors: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SpawnRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SpawnRequest
  ): SpawnRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated eigr.functions.protocol.actors.ActorId actors */ 1:
          message.actors.push(ActorId.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SpawnRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated eigr.functions.protocol.actors.ActorId actors = 1; */
    for (let i = 0; i < message.actors.length; i++)
      ActorId.internalBinaryWrite(
        message.actors[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.SpawnRequest
 */
export const SpawnRequest = new SpawnRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SpawnResponse$Type extends MessageType<SpawnResponse> {
  constructor() {
    super('eigr.functions.protocol.SpawnResponse', [
      { no: 1, name: 'status', kind: 'message', T: () => RequestStatus }
    ])
  }
  create(value?: PartialMessage<SpawnResponse>): SpawnResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SpawnResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SpawnResponse
  ): SpawnResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.RequestStatus status */ 1:
          message.status = RequestStatus.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.status
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SpawnResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.RequestStatus status = 1; */
    if (message.status)
      RequestStatus.internalBinaryWrite(
        message.status,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.SpawnResponse
 */
export const SpawnResponse = new SpawnResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ProxyInfo$Type extends MessageType<ProxyInfo> {
  constructor() {
    super('eigr.functions.protocol.ProxyInfo', [
      { no: 1, name: 'protocol_major_version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: 'protocol_minor_version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'proxy_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'proxy_version', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<ProxyInfo>): ProxyInfo {
    const message = {
      protocolMajorVersion: 0,
      protocolMinorVersion: 0,
      proxyName: '',
      proxyVersion: ''
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ProxyInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ProxyInfo
  ): ProxyInfo {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 protocol_major_version */ 1:
          message.protocolMajorVersion = reader.int32()
          break
        case /* int32 protocol_minor_version */ 2:
          message.protocolMinorVersion = reader.int32()
          break
        case /* string proxy_name */ 3:
          message.proxyName = reader.string()
          break
        case /* string proxy_version */ 4:
          message.proxyVersion = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ProxyInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int32 protocol_major_version = 1; */
    if (message.protocolMajorVersion !== 0)
      writer.tag(1, WireType.Varint).int32(message.protocolMajorVersion)
    /* int32 protocol_minor_version = 2; */
    if (message.protocolMinorVersion !== 0)
      writer.tag(2, WireType.Varint).int32(message.protocolMinorVersion)
    /* string proxy_name = 3; */
    if (message.proxyName !== '') writer.tag(3, WireType.LengthDelimited).string(message.proxyName)
    /* string proxy_version = 4; */
    if (message.proxyVersion !== '')
      writer.tag(4, WireType.LengthDelimited).string(message.proxyVersion)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.ProxyInfo
 */
export const ProxyInfo = new ProxyInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SideEffect$Type extends MessageType<SideEffect> {
  constructor() {
    super('eigr.functions.protocol.SideEffect', [
      { no: 1, name: 'request', kind: 'message', T: () => InvocationRequest }
    ])
  }
  create(value?: PartialMessage<SideEffect>): SideEffect {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<SideEffect>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SideEffect
  ): SideEffect {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.InvocationRequest request */ 1:
          message.request = InvocationRequest.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.request
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SideEffect,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.InvocationRequest request = 1; */
    if (message.request)
      InvocationRequest.internalBinaryWrite(
        message.request,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.SideEffect
 */
export const SideEffect = new SideEffect$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Broadcast$Type extends MessageType<Broadcast> {
  constructor() {
    super('eigr.functions.protocol.Broadcast', [
      { no: 1, name: 'channel_group', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'command_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'value', kind: 'message', oneof: 'payload', T: () => Any },
      { no: 4, name: 'noop', kind: 'message', oneof: 'payload', T: () => Noop }
    ])
  }
  create(value?: PartialMessage<Broadcast>): Broadcast {
    const message = { channelGroup: '', commandName: '', payload: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Broadcast>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Broadcast
  ): Broadcast {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string channel_group */ 1:
          message.channelGroup = reader.string()
          break
        case /* string command_name */ 2:
          message.commandName = reader.string()
          break
        case /* google.protobuf.Any value */ 3:
          message.payload = {
            oneofKind: 'value',
            value: Any.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).value
            )
          }
          break
        case /* eigr.functions.protocol.Noop noop */ 4:
          message.payload = {
            oneofKind: 'noop',
            noop: Noop.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).noop
            )
          }
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Broadcast,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string channel_group = 1; */
    if (message.channelGroup !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.channelGroup)
    /* string command_name = 2; */
    if (message.commandName !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.commandName)
    /* google.protobuf.Any value = 3; */
    if (message.payload.oneofKind === 'value')
      Any.internalBinaryWrite(
        message.payload.value,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.Noop noop = 4; */
    if (message.payload.oneofKind === 'noop')
      Noop.internalBinaryWrite(
        message.payload.noop,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.Broadcast
 */
export const Broadcast = new Broadcast$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Pipe$Type extends MessageType<Pipe> {
  constructor() {
    super('eigr.functions.protocol.Pipe', [
      { no: 1, name: 'actor', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'command_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<Pipe>): Pipe {
    const message = { actor: '', commandName: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Pipe>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Pipe
  ): Pipe {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string actor */ 1:
          message.actor = reader.string()
          break
        case /* string command_name */ 2:
          message.commandName = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Pipe,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string actor = 1; */
    if (message.actor !== '') writer.tag(1, WireType.LengthDelimited).string(message.actor)
    /* string command_name = 2; */
    if (message.commandName !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.commandName)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.Pipe
 */
export const Pipe = new Pipe$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Forward$Type extends MessageType<Forward> {
  constructor() {
    super('eigr.functions.protocol.Forward', [
      { no: 1, name: 'actor', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'command_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<Forward>): Forward {
    const message = { actor: '', commandName: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Forward>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Forward
  ): Forward {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string actor */ 1:
          message.actor = reader.string()
          break
        case /* string command_name */ 2:
          message.commandName = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Forward,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string actor = 1; */
    if (message.actor !== '') writer.tag(1, WireType.LengthDelimited).string(message.actor)
    /* string command_name = 2; */
    if (message.commandName !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.commandName)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.Forward
 */
export const Forward = new Forward$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Workflow$Type extends MessageType<Workflow> {
  constructor() {
    super('eigr.functions.protocol.Workflow', [
      { no: 2, name: 'broadcast', kind: 'message', T: () => Broadcast },
      {
        no: 1,
        name: 'effects',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => SideEffect
      },
      { no: 3, name: 'pipe', kind: 'message', oneof: 'routing', T: () => Pipe },
      { no: 4, name: 'forward', kind: 'message', oneof: 'routing', T: () => Forward }
    ])
  }
  create(value?: PartialMessage<Workflow>): Workflow {
    const message = { effects: [], routing: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<Workflow>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Workflow
  ): Workflow {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.Broadcast broadcast */ 2:
          message.broadcast = Broadcast.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.broadcast
          )
          break
        case /* repeated eigr.functions.protocol.SideEffect effects */ 1:
          message.effects.push(SideEffect.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* eigr.functions.protocol.Pipe pipe */ 3:
          message.routing = {
            oneofKind: 'pipe',
            pipe: Pipe.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.routing as any).pipe
            )
          }
          break
        case /* eigr.functions.protocol.Forward forward */ 4:
          message.routing = {
            oneofKind: 'forward',
            forward: Forward.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.routing as any).forward
            )
          }
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Workflow,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.Broadcast broadcast = 2; */
    if (message.broadcast)
      Broadcast.internalBinaryWrite(
        message.broadcast,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated eigr.functions.protocol.SideEffect effects = 1; */
    for (let i = 0; i < message.effects.length; i++)
      SideEffect.internalBinaryWrite(
        message.effects[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.Pipe pipe = 3; */
    if (message.routing.oneofKind === 'pipe')
      Pipe.internalBinaryWrite(
        message.routing.pipe,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.Forward forward = 4; */
    if (message.routing.oneofKind === 'forward')
      Forward.internalBinaryWrite(
        message.routing.forward,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.Workflow
 */
export const Workflow = new Workflow$Type()
// @generated message type with reflection information, may provide speed optimized methods
class InvocationRequest$Type extends MessageType<InvocationRequest> {
  constructor() {
    super('eigr.functions.protocol.InvocationRequest', [
      { no: 1, name: 'system', kind: 'message', T: () => ActorSystem },
      { no: 2, name: 'actor', kind: 'message', T: () => Actor },
      { no: 3, name: 'command_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'value', kind: 'message', oneof: 'payload', T: () => Any },
      { no: 7, name: 'noop', kind: 'message', oneof: 'payload', T: () => Noop },
      { no: 5, name: 'async', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 6, name: 'caller', kind: 'message', T: () => ActorId },
      {
        no: 8,
        name: 'metadata',
        kind: 'map',
        K: 9 /*ScalarType.STRING*/,
        V: { kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
      },
      {
        no: 9,
        name: 'scheduled_to',
        kind: 'scalar',
        T: 3 /*ScalarType.INT64*/,
        L: 0 /*LongType.BIGINT*/
      },
      { no: 10, name: 'pooled', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
    ])
  }
  create(value?: PartialMessage<InvocationRequest>): InvocationRequest {
    const message = {
      commandName: '',
      payload: { oneofKind: undefined },
      async: false,
      metadata: {},
      scheduledTo: 0n,
      pooled: false
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<InvocationRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: InvocationRequest
  ): InvocationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.actors.ActorSystem system */ 1:
          message.system = ActorSystem.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.system
          )
          break
        case /* eigr.functions.protocol.actors.Actor actor */ 2:
          message.actor = Actor.internalBinaryRead(reader, reader.uint32(), options, message.actor)
          break
        case /* string command_name */ 3:
          message.commandName = reader.string()
          break
        case /* google.protobuf.Any value */ 4:
          message.payload = {
            oneofKind: 'value',
            value: Any.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).value
            )
          }
          break
        case /* eigr.functions.protocol.Noop noop */ 7:
          message.payload = {
            oneofKind: 'noop',
            noop: Noop.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).noop
            )
          }
          break
        case /* bool async */ 5:
          message.async = reader.bool()
          break
        case /* eigr.functions.protocol.actors.ActorId caller */ 6:
          message.caller = ActorId.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.caller
          )
          break
        case /* map<string, string> metadata */ 8:
          this.binaryReadMap8(message.metadata, reader, options)
          break
        case /* int64 scheduled_to */ 9:
          message.scheduledTo = reader.int64().toBigInt()
          break
        case /* bool pooled */ 10:
          message.pooled = reader.bool()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  private binaryReadMap8(
    map: InvocationRequest['metadata'],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof InvocationRequest['metadata'] | undefined,
      val: InvocationRequest['metadata'][any] | undefined
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case 1:
          key = reader.string()
          break
        case 2:
          val = reader.string()
          break
        default:
          throw new globalThis.Error(
            'unknown map entry field for field eigr.functions.protocol.InvocationRequest.metadata'
          )
      }
    }
    map[key ?? ''] = val ?? ''
  }
  internalBinaryWrite(
    message: InvocationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.actors.ActorSystem system = 1; */
    if (message.system)
      ActorSystem.internalBinaryWrite(
        message.system,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.Actor actor = 2; */
    if (message.actor)
      Actor.internalBinaryWrite(
        message.actor,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string command_name = 3; */
    if (message.commandName !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.commandName)
    /* google.protobuf.Any value = 4; */
    if (message.payload.oneofKind === 'value')
      Any.internalBinaryWrite(
        message.payload.value,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.Noop noop = 7; */
    if (message.payload.oneofKind === 'noop')
      Noop.internalBinaryWrite(
        message.payload.noop,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* bool async = 5; */
    if (message.async !== false) writer.tag(5, WireType.Varint).bool(message.async)
    /* eigr.functions.protocol.actors.ActorId caller = 6; */
    if (message.caller)
      ActorId.internalBinaryWrite(
        message.caller,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* map<string, string> metadata = 8; */
    for (let k of Object.keys(message.metadata))
      writer
        .tag(8, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.LengthDelimited)
        .string(message.metadata[k])
        .join()
    /* int64 scheduled_to = 9; */
    if (message.scheduledTo !== 0n) writer.tag(9, WireType.Varint).int64(message.scheduledTo)
    /* bool pooled = 10; */
    if (message.pooled !== false) writer.tag(10, WireType.Varint).bool(message.pooled)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.InvocationRequest
 */
export const InvocationRequest = new InvocationRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ActorInvocation$Type extends MessageType<ActorInvocation> {
  constructor() {
    super('eigr.functions.protocol.ActorInvocation', [
      { no: 1, name: 'actor', kind: 'message', T: () => ActorId },
      { no: 2, name: 'command_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'current_context', kind: 'message', T: () => Context },
      { no: 4, name: 'value', kind: 'message', oneof: 'payload', T: () => Any },
      { no: 5, name: 'noop', kind: 'message', oneof: 'payload', T: () => Noop },
      { no: 6, name: 'caller', kind: 'message', T: () => ActorId }
    ])
  }
  create(value?: PartialMessage<ActorInvocation>): ActorInvocation {
    const message = { commandName: '', payload: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ActorInvocation>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ActorInvocation
  ): ActorInvocation {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.actors.ActorId actor */ 1:
          message.actor = ActorId.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.actor
          )
          break
        case /* string command_name */ 2:
          message.commandName = reader.string()
          break
        case /* eigr.functions.protocol.Context current_context */ 3:
          message.currentContext = Context.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.currentContext
          )
          break
        case /* google.protobuf.Any value */ 4:
          message.payload = {
            oneofKind: 'value',
            value: Any.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).value
            )
          }
          break
        case /* eigr.functions.protocol.Noop noop */ 5:
          message.payload = {
            oneofKind: 'noop',
            noop: Noop.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).noop
            )
          }
          break
        case /* eigr.functions.protocol.actors.ActorId caller */ 6:
          message.caller = ActorId.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.caller
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ActorInvocation,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.actors.ActorId actor = 1; */
    if (message.actor)
      ActorId.internalBinaryWrite(
        message.actor,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string command_name = 2; */
    if (message.commandName !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.commandName)
    /* eigr.functions.protocol.Context current_context = 3; */
    if (message.currentContext)
      Context.internalBinaryWrite(
        message.currentContext,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Any value = 4; */
    if (message.payload.oneofKind === 'value')
      Any.internalBinaryWrite(
        message.payload.value,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.Noop noop = 5; */
    if (message.payload.oneofKind === 'noop')
      Noop.internalBinaryWrite(
        message.payload.noop,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.ActorId caller = 6; */
    if (message.caller)
      ActorId.internalBinaryWrite(
        message.caller,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.ActorInvocation
 */
export const ActorInvocation = new ActorInvocation$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ActorInvocationResponse$Type extends MessageType<ActorInvocationResponse> {
  constructor() {
    super('eigr.functions.protocol.ActorInvocationResponse', [
      { no: 1, name: 'actor_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'actor_system', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'updated_context', kind: 'message', T: () => Context },
      { no: 4, name: 'value', kind: 'message', oneof: 'payload', T: () => Any },
      { no: 6, name: 'noop', kind: 'message', oneof: 'payload', T: () => Noop },
      { no: 5, name: 'workflow', kind: 'message', T: () => Workflow }
    ])
  }
  create(value?: PartialMessage<ActorInvocationResponse>): ActorInvocationResponse {
    const message = { actorName: '', actorSystem: '', payload: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<ActorInvocationResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ActorInvocationResponse
  ): ActorInvocationResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string actor_name */ 1:
          message.actorName = reader.string()
          break
        case /* string actor_system */ 2:
          message.actorSystem = reader.string()
          break
        case /* eigr.functions.protocol.Context updated_context */ 3:
          message.updatedContext = Context.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.updatedContext
          )
          break
        case /* google.protobuf.Any value */ 4:
          message.payload = {
            oneofKind: 'value',
            value: Any.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).value
            )
          }
          break
        case /* eigr.functions.protocol.Noop noop */ 6:
          message.payload = {
            oneofKind: 'noop',
            noop: Noop.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).noop
            )
          }
          break
        case /* eigr.functions.protocol.Workflow workflow */ 5:
          message.workflow = Workflow.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.workflow
          )
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ActorInvocationResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string actor_name = 1; */
    if (message.actorName !== '') writer.tag(1, WireType.LengthDelimited).string(message.actorName)
    /* string actor_system = 2; */
    if (message.actorSystem !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.actorSystem)
    /* eigr.functions.protocol.Context updated_context = 3; */
    if (message.updatedContext)
      Context.internalBinaryWrite(
        message.updatedContext,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Any value = 4; */
    if (message.payload.oneofKind === 'value')
      Any.internalBinaryWrite(
        message.payload.value,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.Noop noop = 6; */
    if (message.payload.oneofKind === 'noop')
      Noop.internalBinaryWrite(
        message.payload.noop,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.Workflow workflow = 5; */
    if (message.workflow)
      Workflow.internalBinaryWrite(
        message.workflow,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.ActorInvocationResponse
 */
export const ActorInvocationResponse = new ActorInvocationResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class InvocationResponse$Type extends MessageType<InvocationResponse> {
  constructor() {
    super('eigr.functions.protocol.InvocationResponse', [
      { no: 1, name: 'status', kind: 'message', T: () => RequestStatus },
      { no: 2, name: 'system', kind: 'message', T: () => ActorSystem },
      { no: 3, name: 'actor', kind: 'message', T: () => Actor },
      { no: 4, name: 'value', kind: 'message', oneof: 'payload', T: () => Any },
      { no: 5, name: 'noop', kind: 'message', oneof: 'payload', T: () => Noop }
    ])
  }
  create(value?: PartialMessage<InvocationResponse>): InvocationResponse {
    const message = { payload: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<InvocationResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: InvocationResponse
  ): InvocationResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.RequestStatus status */ 1:
          message.status = RequestStatus.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.status
          )
          break
        case /* eigr.functions.protocol.actors.ActorSystem system */ 2:
          message.system = ActorSystem.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.system
          )
          break
        case /* eigr.functions.protocol.actors.Actor actor */ 3:
          message.actor = Actor.internalBinaryRead(reader, reader.uint32(), options, message.actor)
          break
        case /* google.protobuf.Any value */ 4:
          message.payload = {
            oneofKind: 'value',
            value: Any.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).value
            )
          }
          break
        case /* eigr.functions.protocol.Noop noop */ 5:
          message.payload = {
            oneofKind: 'noop',
            noop: Noop.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.payload as any).noop
            )
          }
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: InvocationResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.RequestStatus status = 1; */
    if (message.status)
      RequestStatus.internalBinaryWrite(
        message.status,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.ActorSystem system = 2; */
    if (message.system)
      ActorSystem.internalBinaryWrite(
        message.system,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.actors.Actor actor = 3; */
    if (message.actor)
      Actor.internalBinaryWrite(
        message.actor,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Any value = 4; */
    if (message.payload.oneofKind === 'value')
      Any.internalBinaryWrite(
        message.payload.value,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* eigr.functions.protocol.Noop noop = 5; */
    if (message.payload.oneofKind === 'noop')
      Noop.internalBinaryWrite(
        message.payload.noop,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.InvocationResponse
 */
export const InvocationResponse = new InvocationResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RequestStatus$Type extends MessageType<RequestStatus> {
  constructor() {
    super('eigr.functions.protocol.RequestStatus', [
      { no: 1, name: 'status', kind: 'enum', T: () => ['eigr.functions.protocol.Status', Status] },
      { no: 2, name: 'message', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<RequestStatus>): RequestStatus {
    const message = { status: 0, message: '' }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this })
    if (value !== undefined) reflectionMergePartial<RequestStatus>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RequestStatus
  ): RequestStatus {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* eigr.functions.protocol.Status status */ 1:
          message.status = reader.int32()
          break
        case /* string message */ 2:
          message.message = reader.string()
          break
        default:
          let u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RequestStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* eigr.functions.protocol.Status status = 1; */
    if (message.status !== 0) writer.tag(1, WireType.Varint).int32(message.status)
    /* string message = 2; */
    if (message.message !== '') writer.tag(2, WireType.LengthDelimited).string(message.message)
    let u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message eigr.functions.protocol.RequestStatus
 */
export const RequestStatus = new RequestStatus$Type()
